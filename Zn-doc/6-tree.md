# 树

树，是这里最巧妙的设计，实现了 `函数 列表 字典` 三合一。

你还可以使用`闭包面向对象`，以及`惰性求值`。

首先了解栽种，什么是栽种?

要了解栽种，首先要了解[表达式](9-expression)，表达式是栽种的对象

每个树的结构内部均可以 `栽种` 多个`表达式`，将他们使用`空格` 或其他 `空白字符` 隔开即可（空白字符包括：`\n`, `\t`, `\s`）

在解析阶段，Zn首先解析根代码的`表达式列`，对其中的`子树`进行递归解析，直到最内层

这里给出[栽种解析测试]()

栽种列，他是填充`树`的核心。

聪明的你可以看到，`值的栽种`过程中本身是执行语句的过程，这就实现顺序逻辑堆叠

---


## 树的建立
1. 首先，代码根环境本身就是一颗树，称：`母树`，只是没有可见的 `{}`，所以你的代码从树开始，首先了解树的机制很重要。

2. 要建立你自己的树，请使用`{}`，这些树生长在`母树`上，称`子树`

---

## 键的自定义
要知道，这其实是在使 `赋值` 合理化。

在树中，配合`=`语法实现键的自定义，比如：
```c
{7 8 9 a=3 b=4}
// ----
键   值
1    7
2    8
3    9
4    3
5    4
"a"  3     // 我们在这里看到了自定义了的键
"b"  4
```

这里 `a=3` 在填充第`4`个值列的同时给树增加一个名为`"a"`的键

要讨论`访问到自定义键的值`的问题，分为两类：树内，树外

- 树内
```c
{a=1 b=a+1}
```

- 树外
```c
f = {a=1 b=a+1}
f.a                 // 你可以直接访问到.a
f['a']              // 使用索引
f[1]                // 使用索引
```

特别地，由于根代码也是树，在树内访问就像利用变量一样简单
```c
a = 1
b = a + 1
```

而在树外访问，这离开Zn，发生在宿主层面

---

## 求值时机

这里讲解求值时机，需理解以控制程序正确时机进行求值

1. 立刻求值
```c
a = 1
f = {sin(a) cos(a+1)} // 立刻求值，存储在树中
```

2. 惰性求值
```c
a = 1
f = (){sin(a) cos(a+1)} // 创建闭包函数，不执行
f()                     // 现在执行
```

可以看到只要在 `{}` 前加 `()` 则是函数场景，`()`会`抑制`立刻求值，而`f()`触发了求值，称触发条件。

以下是所有触发条件：
```c
f = (){ln(e) a=lg(10)}  // 
f[1]                    // 访问到第一个栽种值
f.a                     // 指定到键a
f()                     // 作为函数调用
(print)for(f)           // 系统遍历函数，输出：1 1
```

立刻求值是`链式`的，这意味着：
```c
f = (){
	{print(2)}
}
```

`f` 被 `()` 抑制，内部 `{print(2)}` 无法立刻求值并填充为表

---
## 作为函数

### 1. 函数参数

```c
f=(参数){}
```

### 2. 函数过程，闭包

闭包
```c
Line = (p v){
	(t){p + t * v}
}
//
line1 = Line(Vec(1 1) Vec(2 2))
p1 = line1(0.5)

```

变量使用
```c
a = 1
f = (a){a+1}
f(2)              // -> 3
```


### 3. 插队

这是实现`面向对象`和`惰性求值`的重要特性
```c
f=(){
	a = 1
	b = 2
	c = a + 1
	d = b
}
f.c                      // 插队，只求解c
```

求 `c`，我们只会惰性寻求 `c` 计算时依赖的上游变量（递归）

接下来看面向对象如何实现
```c
Conic0 = (a b){
	{
		area = pi * a * b
		c = sqrt(a^2 - b^2)
		e = c/a
	}
}
// ---------------------------------
c0 = Conic0(2 1)
c0.e
```

这里的 `area`，`c`，`e` 事实上就是`get方法`，我们的`插队机制`保证了只进行必要的惰性计算。

### 4. 返回值

默认使用最后的值作为返回值
```c
f = (){}
```

### 5. 数学语法糖

我们完全支持这样写
```c
f(x) = x^2
```

注意，这里的 `x^2` 是惰性的，不会立刻求值

有时，如果需要多次操作，而非像这里 `x^2` 步出结果，你可以写作：

```c
f(x) = {step1 step2 result}()
// 这等效于
f = (x){
	{step1 step2 result}()
}
```

上文提到的链式求值在这里意味着 `{step1 step2 result}()` 不会立刻执行，直到 `f` 执行

---

## 作为表（字典）

这是简单的：
```c
tom = {type="cat" age=3 friend="jerry"}
```


## 作为列表

这是也简单的：
```c
list = {1 2 3 4 5 6 7 8 9}

```
