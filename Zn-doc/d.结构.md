# 结构

#### 预备概念

1. `量定义`：

```Dart
a 1 "" <> [] {} ()
abc 1.23
(1) ("") (<>) ({}) ([]) ((1))
```

2. `函数调用`

- a. 赋值函数(=)调用
```Dart
a=1 a="" a=<> a=[]    // 除函数以外类型
a=(){} a()=0 a={}     // 定义有名函数
```

- b. 前缀调用

```
// 
f()  {}()  (){}()
// 前缀一元运算符
(-1)
```

- c. 中缀调用

```Dart
//假设f是函数
{}f{} {}f() {}f<> {}f"" {}f[]
()f{} ()f() ()f<> ()f"" ()f[]
<>f{} <>f() <>f<> <>f"" <>f[]
""f{} ""f() ""f<> ""f"" ""f[]
[]f{} []f() []f<> []f"" []f[]

// 循环语句
{}for() {}loop() {}while{}

```

- d. 中缀运算符
```Dart
// 2.2.1 中缀运算符
1 + 1 - 3 * 4 / 5 ^ 6 ?= 5 % 2 != 5 ?< 8 ?> 7 <= 4 >= 3
// 2.2.1.1 条件和三元表达式
()?() {}?() ""?() <>?() []?()
{}??():{}
```

- e. 访问

```Dart
<>.a  <>[1]  <>:a  <>.a()  a.a  a[1]  a:a
```

3. `表达式`：`量定义`或者`函数调用`


---
#### 结构定义
1. `森林`：整个`Zn`程序文件，每个文件只有一个
2. `树`：存在子结构的`表达式`，有`函数`，`向量`，`表`，`函数调用`
3. `灌木`：没有子结构的`表达式`，有`标签`，`字符字面量`，`数字字面量`三种
#### 函数域

`森林环境本身` 和 `函数定义的函数体`

森林环境本身（程序最外层）本身是函数体，所以你可以直接开始栽种值列

```Zn
1 2 3 4 5
6	7
```

像这样，每两个值用`*空白字符`间隔（`*`空白字符包括：空格，换行，制表符）

为什么有这个概念

由于每个函数调用后都会返回值，所以从宏观层面，
```Zn
a = 1
{print("Hello Zincum !")} ?? (a?=1)
114514

// -------------------------------------------------
// = (赋值)函数返回目标值 1
// ?? (条件)函数返回执行函数 {print("Hello Zincum !")}
// 数字字面量114514
```
这段代码在`root`函数里实质上是`栽种`了三个值：`1` ， `{print("Hello Zincum !")}`，`114514`

聪明的你可以看到，`值的栽种`过程中本身是执行语句的过程，这就实现顺序逻辑堆叠
#### 栽种列

在函数体中用空白字符隔开的一系列表达式

### 4. 树

存在子结构的`表达式`

#### (1) 函数域



## 3. root返回值

对于没有返回声明的非空函数，返回值是`最后一个栽种值`（详见：函数返回）

`root`函数（根代码）同样不例外，将返回`最后一个栽种值`，这使得外部环境（宿主）可以获得这个值

```Zn
1+1
```

像这样，外部程序接收到`2`，这样一来，可以恰好满足`高阶计算器解析器`的需求（每行表达式都可以是独立程序。当然，也可以使用`环境`包裹，使得值共享）
