想象这样一种语言

语法设计极简，表现力强，语法构成完全是`函数调用`和`量定义`

实现相同功能的字符数平均只有其他语言的50%

设计作为高阶计算器解析器，可以运行单行表达式

# 一  入门

Zn没有任何关键字
你要么在写量要么在函数调取

## 1. 栽种值列

每个`函数域`内允许`栽种值列`。

特别地：程序最外层本身是`root`函数，所以你可以直接开始栽种值列
```Zn
1 2 3 4 5
6	7
```
像这样，每两个值用`*空白字符`间隔（`*`空白字符包括：空格，换行，制表符）

## 2. 为什么有这个概念

由于每个函数调用后都会返回值，所以从宏观层面，
```Zn
a = 1
{print("Hello Zincum !")} ?? (a?=1)
114514

// = (赋值)函数返回目标值 1
// ?? (条件)函数返回执行函数 {print("Hello Zincum !")}
// 数字字面量114514
```
这段代码在`root`函数里实质上是`栽种`了三个值：`1` ， `{print("Hello Zincum !")}`，`114514`

聪明的你可以看到，`值的栽种`过程中本身是执行语句的过程，这就实现顺序逻辑堆叠

## 3. root返回值

对于没有返回声明的非空函数，返回值是`最后一个栽种值`（详见：函数返回）

`root`函数（根代码）同样不例外，将返回`最后一个栽种值`，这使得外部环境（宿主）可以获得这个值
```Zn
1+1
```

像这样，外部程序接收到`2`，这样一来，可以恰好满足`高阶计算器解析器`的需求（每行表达式都可以是独立程序。当然，也可以使用`环境`包裹，使得值共享）

# 二  量

## 1. 字面量

直接读取的量

| 字面量类型    | 例子  |
| -------- | --- |
| 标签（隐字面量） | a   |
| 数字       | 1   |
| 字符       | "a" |

## 2. 定义量

定义量有明确语法，并且需要其他 `定义量` 和 `字面量` 联合构成

| 定义量类型  | 例子                             |
| ------ | ------------------------------ |
| root函数 | （空白）                           |
| 函数     | `(){}` 或 `{}` 或 `f(x)=x`(数学友好) |
| 向量     | `<>`                           |
| 表      | `[]`                           |

# 三  函数

## 1. 函数表

- 运算符函数

| 符号  | 作用    | 示例            | 返回值     |
| --- | ----- | ------------- | ------- |
| =   | 赋值    | a=1           | 目标值     |
| +   | 相加    | 1+1           | 计算值     |
| -   | 相减    | 1-1           | 计算值     |
| *   | 相乘    | 1*1           | 计算值     |
| /   | 相除    | 1/1           | 计算值     |
| %   | 整除取余  | 1%1           | 计算值     |
| ^   | 指数幂   | 1^1           | 计算值     |
| ++  | 自增+1  | c++           | 计算值     |
| --  | 自减-1  | i--           | 计算值     |
| :   | 操作    | obj:fuck()    | 操作函数返回值 |
| .   | 索引    | map.a         | 索引得到值   |
| []  | 索引    | map["ss"]     | 索引得到值   |
| ??  | 条件判断  | {}??(1)       | 判断值     |
| ?   | 三目表达式 | "love"?1:"no" | 目标值     |
| ?=  | 相等    | 1?=1          | 判断值     |
| !=  | 不相等   | 1!=1          | 判断值     |
| ?>  | 大于    | 1?>1          | 判断值     |
| ?<  | 小于    | 1?<1          | 判断值     |
| >=  | 大于或等于 | 1>=1          | 判断值     |
| <=  | 小于或等于 | 1<=1          | 判断值     |
| ~   | 逻辑非   | ~1            | 计算值     |
| &   | 逻辑与   | 1&1           | 计算值     |
| \|  | 逻辑或   | 1\|1          | 计算值     |
| <<  | 注册预返回 | << a          | 无       |
| <-  | 左射    | a<-b          | 计算值     |
| ->  | 右射    | a->b          | 计算值     |
| <-> | 交换值   | a<->b         | 交换后序列向量 |
| #   | 计算长度  | # list        | 计算值     |

- 其他函数详见：扩展函数

## 2. 函数域

如上文，每个`函数域`内允许`栽种值列`。

```
// 使用 f(x)=x 形式定义函数
HaveBreakfast() = 1

// 先创建匿名函数再转移值
HaveLunch = (){2}              // 返回 2

// 无参数变体写法
HaveDinner = {3}               // 返回 3

(){
	HaveBreakfast()
	HaveLunch()
	HaveDinner()
}
```

## 3. 函数返回

每一个函数必定拥有返回值：
1. 对于空函数：返回值是`null`
2. 对于非空函数：
	1. 没有`返回声明`：返回值是`最后一个个栽种值`
	2. 有`返回声明`：
		1. `返回变量标签`未定义：等待，直到标签定义
		2. ~~（弃用） `返回变量标签`定义：立刻返回

我们可以用`<<`定义`预返回`，以实现`在任何子流程return且中止函数`的目的。

```Zn
Factorial = (x){
	<< r        // 定义预返回
	{r = 1}??(x <= 1)
	r = x * Factorial(x-1)
}
```

预返回`<<`是一个占位符，占领`栽种值列`的第一个位置。这种情况下函数不会返回，直到`预返回标签`（这里的`r`）被定义值。

如果你想不使用预返回，也可以这样写：
```Zn
F = (x){
	({1}??(x <= 1):{x * F(x-1)})()
}
```
甚至：
```Zn
F(x) = ({1}??(x <= 1):{x * F(x-1)})()
```
或：
```Zn
F(x)=1?(x<=1):x*F(x-1)
```

# 四  类型系统

## 1. 数字

```Zn
1 + 2 * 3 / 4 - 5 ^ 6 + sin(7) + log(2, 8) + pi
```

## 2. 向量 & 数组

```Zn
b = <1, 2, 3>     // 定义
b = <5..10>       // 填充

<>.add<>          // 

```

## 3. 表 & 类结构

```Zn
c = [
  a = {},          // 直接定义（字符串键）
  ["b"] = 6        // 键值
]
c.c = 0            // 访问插入
c["a"]             // 访问

```

## 4. 函数

```Zn
d = (x){print(x)}
e = {doSTH()}
f(x) = x
```

## 5. 字符

```Zn
g = "哈哈哈"
```

> [!NOTE] 我们没有布尔
> 我们只有伪布尔

```Zn
// 条件识别
{/*do sth*/}??(0)     不运行
{/*do sth*/}??(1)     运行
{/*do sth*/}??(-2)    运行

// 产生
1?=1     -> 1    数值相等
8?%2     -> 1    可以整除

// 运算
1-1      -> 0    not
0&1      -> 0    and
0|1      -> 1    or      


```

# 流程控制

1. if-else
```Zn
{函数}??(条件)
{函数}??(条件):{否则函数}


```

2. 定次循环
```Zn
{函数}loop(次数)  // {函数}loop 次数 类似也可以
(第i次){可以利用i}loop(次数)

// 你想打印1-5
(i){print(i)}loop(5)
// 或者直接调取print
print loop 5
```

3. 遍历循环
```Zn
(i,v){循环函数}for(向量或表)

// 遍历向量
h = <1..5>     // 填充语法
(i,v){print(i+": "+v)}for(h)
```

4. 条件循环
```Zn
{循环函数}while{条件检查函数}

// 注意，条件不可填表达式，要填函数，以便每次检查
// 打印1-5
n=0
{print(n++)}while{n<5}
```

5. 自制循环
```Zn
// 打印1-5
// 目标函数
iWantLoop = (i){
	print(i)
}
// 配置循环
n=0
a={
	iWantLoop(n++)  // n自增同时调用并传入自增后的n
	b??(n<5)       // 条件函数会调用b函数
}
b() = a()           // 基于f(x)=x方式定义
// 开始循环
a()
```

## 示例

1. 阶乘函数
```Zn
Factorial = (x){
	<< r
	{r = 1}??(x <= 1)
	r = x * f(x-1)
}
```

2. 判定素数
```
isPrime=(i){
	<< r
	f=(k){k+=2 {r=0}??(i?%k)}
	(f)loop(i-2)
	r=1
}
```

3. 2-100 质数检测
```
(i,v){
	{print(v+"is prime")} ?? (
		(i){<<r 
			(k){
				k+=2
				{r=0}??(i?%k)
			}loop(i-2)
			r=1
		} (v)
	)
}for<2..100>
```

4. 数组排序
```
a=<>:fill(20, (i){rand()*100})
bubbleSort=(arr){
	<<r
	n = #arr
	(i){swapped = 0
		(j){
			{arr[j] <-> arr[j+1]}
			??
			(swapped = arr[j]?>arr[j + 1])
		}loop(n-i)
		{r=arr} ?? (~swapped)
	}loop(n-1)
	r=arr
}
print(bubbleSort(a))
```



---
by : **Duo - 113530014**

qq-group : **663251235**
