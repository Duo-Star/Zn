
Zn 的运算符优先级必须严格设计，既要符合人类直觉（尤其是数学习惯），又要最大化「无括号可读性」

# 优先级表
从高到低，数字越小优先级越高

| 优先级 | 符号                 | 说明与理由                                              |
| --- | ------------------ | -------------------------------------------------- |
| 1   | ()  {}  < >  [ ]   | 括号、函数体、向量、表构造，最高，毫无争议                              |
| 2   | .   []             | 成员访问和索引，必须紧贴变量，优先级仅次于括号                            |
| 3   | :                  | 方法调用 obj:doSth()，比算术高，和 . 同级但写在后面所以右结合             |
| 4   | ++  --  (后置)       | 自增自减必须紧贴变量                                         |
| 5   | ^                  | 幂运算，经典右结合                                          |
| 6   | *   /   %          | 乘除取余，左结合                                           |
| 7   | +   -              | 加减，左结合                                             |
| 8   | ?>  ?<  >=  <=     | 比较运算符                                              |
| 9   | ?=   !=            | 相等/不等，优先级低于大小比较（和几乎所有语言保持一致）                       |
| 10  | ~                  | 逻辑非                                                |
| 11  | &                  | 逻辑与                                                |
| 12  | \|                 | 逻辑或（注意是单竖线）                                        |
| 13  | <-   ->   <->      | 射/交换系列，属于“带副作用的赋值类”，优先级要低                          |
| 14  | =                  | 赋值是最低的二元运算符（经典设计），必须最后执行                           |
| 15  | ??                 | 条件执行后缀，必须比赋值还低！否则 a=1??(x>0) 会变成 a=(1??(x>0)) 彻底坏掉 |
| 16  | ?                  | 三目，必须在 ?? 之下，否则 "a"?b:c ??(d) 解析会乱套                |
| 17  | loop   while   for | 循环后缀，优先级最低中的最低！它们必须作用在整个前面的函数块上                    |
| 18  | <<                 | 预返回声明，属于函数体内部的“语句级”东西，比任何后缀都低，实际在函数体内解析            |

关键的“保底设计”原则（必须死守）：

1. 所有后缀算子（??、?、loop、for、while）的优先级都必须低于 =  
   否则这几句全都会解析错误：
   ```zn
   a=0?(x>0)     → 必须是 a=(0??(x>0)) 完全错
   f={print(i++)}loop(10)  → 必须完整绑定 {print(i++)} 再 loop
   ```

2. ?? 必须比 ? 高  
   否则：
   ```zn
   a?b:c ??(d)   → 会错解析成 (a?b:c ??(d))
   ```

3. loop/for/while 是绝对最低优先级  
   允许疯狂的写法继续成立：
   ```zn
   print loop 10
   {print(i++)}loop(100)??(x)
   (i,v){print(v)}for<1..100>??(flag)
   ```

完整优先级表（最终版，建议直接刻进解析器）：

| 优先级 | 符号                            | 结合性    |
|-------|--------------------------------|-----------|
| 1     | () {} <> []                    | -         |
| 2     | .  []                          | 左        |
| 3     | :                              | 左        |
| 4     | ++ -- (后置)                   | -         |
| 5     | ^                              | 右        |
| 6     | * / %                          | 左        |
| 7     | + -                            | 左        |
| 8     | ?> ?< >= <=                    | 左        |
| 9     | ?= !=                          | 左        |
|10     | ~                              | 右        |
|11     | &                              | 左        |
|12     | |                              | 左        |
|13     | <- -> <->                      | 右        |
|14     | =                              | 右        |
|15     | ??                             | 右        |
|16     | ?                              | 右        |
|17     | loop while for                 | 左（实际作为后缀修饰符特殊处理） |
|18     | <<                             | -（函数体内特殊声明） |

有了这张表，Zn 才能真正做到「几乎永远不需要括号」的同时还不发生歧义。

这才是配得上 Zn 变态表现力的优先级设计。