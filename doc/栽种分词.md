
- 如何切值

可能断掉的尾值：

| 符    | 后面必须有                 | 或后面紧接着 |
| ---- | --------------------- | ------ |
| )    | = : + - * / , > ] } ) | {      |
| ]    | : + - * / , > ] } )   | [标签]   |
| }    | : + - * / , > ] } )   | [标签]   |
| >    | : + - * / , > ] } )   | [标签]   |
| [数字] | : + - * / , > ] } )   |        |
| [标签] | = : + - * / , > ] } ) | (      |
否则就是断


```dart
// 分割树  
List<String> divTree(String code) {  
  // 移除注释  
  code = removeComments(code);  
  // 任务列表  
  List<DivTask> taskList = [];  
  // 代码片段  
  List<String> trees = [];  
  // 添加命令  
  void addTask(String type) {  
    RegExp regex;  
    if (type == '/number') {  
      // 匹配到十进制整数小数，不要匹配负数（不包含任何符号）  
      regex = RegExp(r'\b\d+(?:\.\d+)?\b');  
    } else if (type == '/label') {  
      // 必须以字母或下划线开头后面可以跟0个或多个字母、数字或下划线  
      regex = RegExp(r'\b[a-zA-Z_][a-zA-Z0-9_]*\b');  
    } else {  
      // ) ] } > "  
      regex = RegExp(r'[)\]}>"]');  
    }  
    Iterable<RegExpMatch> matches = regex.allMatches(code);  
    List<RegExpMatch> matchList = matches.toList();  
    for (var match in matchList) {  
      String frag = code.substring(match.end);  
      String taskType = (type == 'sign') ? match.group(0) ?? '' : type;  
      taskList.add(DivTask(frag, taskType, match.end));  
      //print('匹配内容："${match.group(0)}", 后续：$frag, taskType：$taskType');  
    }  
  }  
  // 添加匹配  
  addTask('sign');  
  addTask('/number');  
  addTask('/label');  
  // 分割索引表  
  List<int> splitAt = [];  
  // 填充分割索引表  
  for (DivTask dt in taskList) {  
    bool shouldSplit = dt.run();  
    if (shouldSplit) {  
      splitAt.add(dt.index);  
      //print(dt.index);  
    }  
  }  
  // 排序，以便划分字符串  
  splitAt.sort();  
  // 划分字符串，代码片段  
  for (int i = 0; i < splitAt.length; i++) {  
    //print(splitAt[i]);  
    String frag;  
    if (i == 0) {  
      frag = code.substring(0, splitAt[i]);  
    } else {  
      frag = code.substring(splitAt[i - 1], splitAt[i]);  
    }  
    trees.add(frag.trim());  
  }  
  // 整理括号完整性  
  List<String> fix(List<String> trees, Function checkF) {  
    bool ok = true;  
    int illAt = 0;  
    for (int i = 0; i < trees.length; i++) {  
      String s = trees[i];  
      bool health = checkF(s);  
      if (health == false) {  
        ok = false;  
        illAt = i;  
        // 一次只修一个错误  
        break;  
      }  
    }  
    if (ok) {  
      return trees;  
    } else {  
      if (illAt < trees.length - 1) {  
        trees[illAt] = "${trees[illAt]} ${trees[illAt + 1]}";  
        trees.removeAt(illAt + 1);  
        return fix(trees, checkF);  
      } else {  
        return trees;  
      }  
    }  
  }  
  
  void fixAll() {  
    fix(trees, bracket_checker.checkAngleBrackets);  
    fix(trees, bracket_checker.checkCurlyBraces);  
    fix(trees, bracket_checker.checkDoubleQuotes);  
    fix(trees, bracket_checker.checkParentheses);  
    fix(trees, bracket_checker.checkSquareBrackets);  
  }  
  fixAll();  
  return trees;  
}
```